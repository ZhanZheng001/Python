'''
输入一串方波信号，求取最长的完全连续交替方波信号，并将其输出，如果有相同长度的交替方波信号，输出任一即可，方波信号高位用1标识，低位用0标识，如图：
https://myimage-zz.oss-cn-shenzhen.aliyuncs.com/img/202207020803807.png

说明：

一个完整的信号一定以0开始然后以0结尾，即010是一个完整信号，但101，1010，0101不是
输入的一串方波信号是由一个或多个完整信号组成
两个相邻信号之间可能有0个或多个低位，如0110010，011000010
同一个信号中可以有连续的高位，如01110101011110001010，前14位是一个具有连续高位的信号
完全连续交替方波是指10交替，如01010是完全连续交替方波，0110不是

输入描述:
输入信号字符串（长度>=3且<=1024）： 0010101010110000101000010
注：输入总是合法的，不用考虑异常情况

输出描述:
输出最长的完全连续交替方波信号串： 01010 若不存在完全连续交替方波信号串，输出 -1

示例 1
输入:
00101010101100001010010
输出:
01010

备注:
输入信号串中有三个信号：0010101010110(第一个信号段) 0001010(第二个信号段) 010(第三个信号段)
第一个信号虽然有交替的方波信号段，但出现了11部分的连续高位，不算完全连续交替方波，在剩下的连续方波信号串中01010最长
'''
while 1:
    try:
        nums = input()

        # 提取信号段，由0分隔的信号段
        dp = []
        cache = []
        for c in nums:
            if cache and cache[-1] == "0" == c:
                dp.append("".join(cache))
                cache = [c]
            else:
                cache.append(c)
        else:
            if cache:
                dp.append("".join(cache))

        # 取不包含11，长度最大的子串
        # 出现了11部分的连续高位，不算完全连续交替方波
        sub = max(dp, key=lambda x: 0 if "11" in x else len(x))
        print(sub)
    except Exception as e:
        break
