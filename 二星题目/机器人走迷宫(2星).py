'''
题目描述
机器人走一个迷宫,给出迷宫的 x*y 的迷宫并且迷宫中有障碍物,输入k表示障碍物有k个,并且会将障碍物的坐标挨个输入。
机器人从 0,0 的位置走到 x,y 的位置并且只能向 x,y 增加的方向走（即只能向左向下移动）,不能回退。
#表示可以走的方格, 0代表障碍, 机器人从 0,0 的位置只能向下或者向前走到出口。
其中会有不可达方格和陷阱方格.不可达方格为第四行前三个,该机器人在行走路径上不可能走到的方格,陷阱方格如第一行最后两个,走进之后则不能抵达终点。
要求: 分别输出陷阱和不可达方格方格数量。

示例1：
输入：
3 3
2
0 2
2 0
输出：
0 0

示例2：
输入：
4 6
5
1 4
1 5
2 0
2 1
2 2
输出：
2 3
说明：
因为机器人只能向下或向右移动，当进入A区域后，前进无法到达终点，即为陷阱方格，方格数量2
B区域只能由 3,3 位置向左移动到达，所有为不可达方格，方格数量3

示例3：
输入：
4 8
7
1 6
1 7
2 0
2 1
2 2
2 4
2 5
输出：
6 5
'''
# 参考代码
# 我们定义-1是陷阱格子，#是不可达格子；
# 当（i,j）不在迷宫内返回-1，这里无法到达终点；
# 当（i,j）等于0返回-1，这里被障碍物阻挡无法到达终点；
# 当（i,j）等于1返回1，已经到达终点；
# 从（0,0）点出发，（0,0）的结果是 （0,1）和（1,0）中较大的值。

while 1:
    try:
        x, y = map(int, "4 6".split())
        # dp = [["#"] * y for _ in range(x)]
        # for _ in range(int("5")): # 构造迷宫
        #     i, j = map(int, input().split())
        #     dp[i][j] = 0
        dp = [['#', '#', '#', '#', '#', '#'], ['#', '#', '#', '#', 0, 0], [0, 0, 0, '#', '#', '#'], ['#', '#', '#', '#', '#', '#']]
        #[['#', '#', '#', '#', '#', '#'],
        # ['#', '#', '#', '#', 0, 0],
        # [0, 0, 0, '#', '#', '#'],
        # ['#', '#', '#', '#', '#', '#']]
        def dfs(x_, y_):
            if x_ == x - 1 and y_ == y - 1: # 到达终点
                dp[x_][y_] = 1
                return 1
            elif x_ > x - 1 or y_ > y - 1 or dp[x_][y_] == 0: # 到达边界或障碍物
                return -1
            else:
                dp[x_][y_] = max(dfs(x_ + 1, y_), dfs(x_, y_ + 1)) # 更新可以到达的格子
                return dp[x_][y_]
        dfs(0, 0) # 从 0,0 点出发
        #[[1, 1, 1, 1, -1, -1],
        # [1, 1, 1, 1, 0, 0],
        # [0, 0, 0, 1, 1, 1],
        # ['#', '#', '#', 1, 1, 1]]
        c1 = 0
        c2 = 0
        for line in dp:
            c1 += line.count(-1)
            c2 += line.count("#")
        print(c1, c2)
        break
    except Exception as e:
        break
